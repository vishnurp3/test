package com.rbs.risk.cradle.climate.migration.calculator.service;

import com.rbs.risk.cradle.climate.migration.calculator.domain.Module;
import com.rbs.risk.cradle.climate.migration.calculator.domain.Question;
import com.rbs.risk.cradle.climate.migration.calculator.domain.Variable;
import com.rbs.risk.cradle.climate.migration.calculator.dto.ParentQuestMapRow;
import com.rbs.risk.cradle.climate.migration.calculator.dto.QuestionVariableRow;
import com.rbs.risk.cradle.climate.migration.calculator.repository.ModelVersionRepository;
import com.rbs.risk.cradle.climate.migration.calculator.repository.ParentQuestMapRepository;
import com.rbs.risk.cradle.climate.migration.calculator.repository.QuestionVariableRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class CalculatorModelBuilderService {

    private final ModelVersionRepository modelVersionRepository;
    private final QuestionVariableRepository questionVariableRepository;
    private final ParentQuestMapRepository parentQuestMapRepository;

    public List<Module> buildModulesForModel(String modelCode) {
        var modelVerIds = resolveModelVersionIds(modelCode);
        var questionRows = questionVariableRepository.findQuestionVariables(modelVerIds);
        var parentRows = parentQuestMapRepository.findParentQuestMap(modelVerIds);

        var context = buildModelContext(questionRows, parentRows);

        wireParentChildRelations(context.questionsById(), context.parentByChildId());
        applyQuestionOrders(context.questionsById(), parentRows);
        pruneChildQuestionsFromModules(context.modulesById(), context.parentByChildId().keySet());
        sortQuestionsAndChildren(context.modulesById().values());

        return context.modulesById().values().stream()
                .sorted(Comparator.comparingLong(Module::getModuleId))
                .toList();
    }

    private List<Long> resolveModelVersionIds(String modelCode) {
        var modelVerId = modelVersionRepository.findModelVersionId(modelCode);
        var linkedModelVerId = modelVersionRepository.findLinkedModelVersionId(modelVerId);

        var modelVerIds = new ArrayList<Long>(2);
        modelVerIds.add(modelVerId);
        if (linkedModelVerId != null) {
            modelVerIds.add(linkedModelVerId);
        }
        return modelVerIds;
    }

    private ModelBuildContext buildModelContext(List<QuestionVariableRow> questionRows,
                                                List<ParentQuestMapRow> parentRows) {

        Set<Long> validParentQuestionIds = parentRows.stream()
                .map(ParentQuestMapRow::parentQuestionId)
                .collect(Collectors.toSet());

        Map<Long, Question> questionsById = new LinkedHashMap<>();
        Map<Long, Module> modulesById = new LinkedHashMap<>();
        Map<Long, Long> parentByChildId = new LinkedHashMap<>();

        for (var row : questionRows) {

            if (row.parentQuestionId() == null
                    && !validParentQuestionIds.contains(row.questionId())) {
                continue;
            }

            var question = questionsById.computeIfAbsent(
                    row.questionId(),
                    id -> new Question(id, row.questionKey())
            );
            question.addVariable(new Variable(row.variableName(), row.prefix()));

            var module = modulesById.computeIfAbsent(
                    row.moduleId(),
                    id -> new Module(id, row.moduleKey())
            );
            module.addQuestion(question);

            var parentId = row.parentQuestionId();
            if (parentId != null) {
                parentByChildId.put(row.questionId(), parentId);
            }
        }

        return new ModelBuildContext(modulesById, questionsById, parentByChildId);
    }

    private void wireParentChildRelations(Map<Long, Question> questionsById,
                                          Map<Long, Long> parentByChildId) {
        for (var entry : parentByChildId.entrySet()) {
            var childId = entry.getKey();
            var parentId = entry.getValue();

            var parent = questionsById.get(parentId);
            var child = questionsById.get(childId);

            if (parent != null && child != null) {
                parent.addChild(child);
            }
        }
    }

    private void applyQuestionOrders(Map<Long, Question> questionsById,
                                     List<ParentQuestMapRow> parentRows) {
        for (var row : parentRows) {
            var question = questionsById.get(row.parentQuestionId());
            if (question != null) {
                question.setOrderInModule(row.questOrder());
            }
        }
    }

    private void pruneChildQuestionsFromModules(Map<Long, Module> modulesById,
                                                Set<Long> childIds) {
        for (var module : modulesById.values()) {
            module.getQuestions().removeIf(q -> childIds.contains(q.getQuestionId()));
        }
    }

    private void sortQuestionsAndChildren(Collection<Module> modules) {
        for (var module : modules) {
            module.getQuestions().sort(Question::compareTo);
            for (var question : module.getQuestions()) {
                question.getChildren().sort(Question::compareTo);
            }
        }
    }

    private record ModelBuildContext(
            Map<Long, Module> modulesById,
            Map<Long, Question> questionsById,
            Map<Long, Long> parentByChildId
    ) {}
}
