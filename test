package com.rbs.risk.cradle.climate.migration.parentquest;

import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;

@Component
public class ParentQuestCsvParser {

    public List<ParentQuestCsvRecord> parse(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            return List.of();
        }

        try (var reader = new BufferedReader(
                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {

            String headerLine = reader.readLine();
            if (headerLine == null) {
                return List.of();
            }

            String[] headerTokens = parseCsvLine(headerLine);
            List<ParentQuestCsvColumn> columns = resolveColumns(headerTokens);

            List<ParentQuestCsvRecord> result = new ArrayList<>();
            String line;

            while ((line = reader.readLine()) != null) {
                if (line.trim().isEmpty()) {
                    continue;
                }

                String[] tokens = parseCsvLine(line);
                if (tokens.length == 0) {
                    continue;
                }

                Map<ParentQuestCsvColumn, String> values = new EnumMap<>(ParentQuestCsvColumn.class);
                for (int i = 0; i < tokens.length && i < columns.size(); i++) {
                    ParentQuestCsvColumn col = columns.get(i);
                    if (col != null) {
                        values.put(col, tokens[i] != null ? tokens[i].trim() : "");
                    }
                }

                String modelCode = values.getOrDefault(ParentQuestCsvColumn.MODEL_CODE, "");
                long modelVerId = parseLong(values.get(ParentQuestCsvColumn.MODEL_VER_ID));
                long questionId = parseLong(values.get(ParentQuestCsvColumn.QUESTION_ID));
                String questionDescription = values.get(ParentQuestCsvColumn.QUESTION_DESCRIPTION);
                int sectionId = (int) parseLong(values.get(ParentQuestCsvColumn.SECTION_ID));
                Long moduleId = parseLongNullable(values.get(ParentQuestCsvColumn.MODULE_ID));
                String hasRemoved = values.getOrDefault(
                        ParentQuestCsvColumn.HAS_REMOVED_IN_UPPER_VERSIONS, "");
                String isParent = values.getOrDefault(
                        ParentQuestCsvColumn.IS_PARENT_QUESTION, "");
                Integer order = parseIntNullable(values.get(ParentQuestCsvColumn.QUESTION_ORDER));

                result.add(new ParentQuestCsvRecord(
                        modelCode,
                        modelVerId,
                        questionId,
                        questionDescription,
                        sectionId,
                        moduleId,
                        hasRemoved,
                        isParent,
                        order
                ));
            }

            return result;
        } catch (Exception ex) {
            throw new IllegalStateException("Failed to parse Parent Quest CSV", ex);
        }
    }

    private List<ParentQuestCsvColumn> resolveColumns(String[] headerTokens) {
        List<ParentQuestCsvColumn> columns = new ArrayList<>();
        for (String header : headerTokens) {
            String h = header != null ? header.trim() : "";
            ParentQuestCsvColumn col = Arrays.stream(ParentQuestCsvColumn.values())
                    .filter(c -> c.getHeaderLabel().equalsIgnoreCase(h))
                    .findFirst()
                    .orElse(null);
            columns.add(col);
        }
        return columns;
    }

    /**
     * Simple CSV line parser that understands quotes and commas inside quotes.
     * It assumes the same format we use when generating the CSV:
     *  - fields that contain commas/newlines/quotes are wrapped in double quotes
     *  - inner quotes are escaped as ""
     */
    private String[] parseCsvLine(String line) {
        List<String> tokens = new ArrayList<>();
        if (line == null || line.isEmpty()) {
            return new String[0];
        }

        StringBuilder current = new StringBuilder();
        boolean inQuotes = false;

        for (int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);

            if (c == '"') {
                if (inQuotes && i + 1 < line.length() && line.charAt(i + 1) == '"') {
                    // Escaped quote within quoted field: ""
                    current.append('"');
                    i++; // skip next quote
                } else {
                    // Toggle quote state, but don't append the quote itself
                    inQuotes = !inQuotes;
                }
            } else if (c == ',' && !inQuotes) {
                // Field separator
                tokens.add(current.toString());
                current.setLength(0);
            } else {
                current.append(c);
            }
        }

        // Last field
        tokens.add(current.toString());

        return tokens.toArray(new String[0]);
    }

    private long parseLong(String value) {
        if (value == null || value.trim().isEmpty()) {
            return 0L;
        }
        return Long.parseLong(value.trim());
    }

    private Long parseLongNullable(String value) {
        if (value == null || value.trim().isEmpty()) {
            return null;
        }
        return Long.valueOf(value.trim());
    }

    private Integer parseIntNullable(String value) {
        if (value == null || value.trim().isEmpty()) {
            return null;
        }
        return Integer.valueOf(value.trim());
    }
}
