package com.rbs.risk.cradle.climate.migration.domain;

public enum UpgradeType {
    MINOR,
    MAJOR
}
package com.rbs.risk.cradle.climate.migration.domain;

/**
 * High-level “recipes” supported by the migration engine.
 * You can extend this as needed.
 */
public enum MigrationScenario {
    MIGRATE_MODEL_WITH_INCREMENT,   // create table + version + linked version + (later parent mapping)
    CREATE_TABLE_ONLY               // just example – first step only
}
package com.rbs.risk.cradle.climate.migration.api;

import com.rbs.risk.cradle.climate.migration.domain.MigrationScenario;
import com.rbs.risk.cradle.climate.migration.domain.UpgradeType;

public class MigrationRequest {

    private String modelCode;
    private String modelType;          // CRS / CTPA etc.
    private String jira;               // WCR-15203
    private String release;            // R12
    private UpgradeType upgradeType;
    private MigrationScenario scenario;
    private String rootOutputFolder;   // e.g. "migration-output" or ""

    public String getModelCode() {
        return modelCode;
    }

    public void setModelCode(String modelCode) {
        this.modelCode = modelCode;
    }

    public String getModelType() {
        return modelType;
    }

    public void setModelType(String modelType) {
        this.modelType = modelType;
    }

    public String getJira() {
        return jira;
    }

    public void setJira(String jira) {
        this.jira = jira;
    }

    public String getRelease() {
        return release;
    }

    public void setRelease(String release) {
        this.release = release;
    }

    public UpgradeType getUpgradeType() {
        return upgradeType;
    }

    public void setUpgradeType(UpgradeType upgradeType) {
        this.upgradeType = upgradeType;
    }

    public MigrationScenario getScenario() {
        return scenario;
    }

    public void setScenario(MigrationScenario scenario) {
        this.scenario = scenario;
    }

    public String getRootOutputFolder() {
        return rootOutputFolder;
    }

    public void setRootOutputFolder(String rootOutputFolder) {
        this.rootOutputFolder = rootOutputFolder;
    }
}
package com.rbs.risk.cradle.climate.migration.domain;

/**
 * Represents one generated SQL file.
 */
public class GeneratedSqlFile {

    private final String folderPath;
    private final String fileName;
    private final String content;

    public GeneratedSqlFile(String folderPath, String fileName, String content) {
        this.folderPath = folderPath;
        this.fileName = fileName;
        this.content = content;
    }

    public String getFolderPath() {
        return folderPath;
    }

    public String getFileName() {
        return fileName;
    }

    public String getContent() {
        return content;
    }
}
package com.rbs.risk.cradle.climate.migration.domain;

import java.util.List;

/**
 * Shared information about model versions for a given modelCode.
 */
public class ModelVersionInfo {

    private final long activeModelVerId;
    private final String activeModelVersion;
    private final long newModelVerId;
    private final String newModelVersion;
    private final List<Long> existingModelVerIds;

    public ModelVersionInfo(long activeModelVerId,
                            String activeModelVersion,
                            long newModelVerId,
                            String newModelVersion,
                            List<Long> existingModelVerIds) {
        this.activeModelVerId = activeModelVerId;
        this.activeModelVersion = activeModelVersion;
        this.newModelVerId = newModelVerId;
        this.newModelVersion = newModelVersion;
        this.existingModelVerIds = existingModelVerIds;
    }

    public long getActiveModelVerId() {
        return activeModelVerId;
    }

    public String getActiveModelVersion() {
        return activeModelVersion;
    }

    public long getNewModelVerId() {
        return newModelVerId;
    }

    public String getNewModelVersion() {
        return newModelVersion;
    }

    public List<Long> getExistingModelVerIds() {
        return existingModelVerIds;
    }
}
package com.rbs.risk.cradle.climate.migration.domain;

/**
 * One row of parent-child mapping, used for CSV-based parent mapping step.
 */
public class ParentQuestionMappingRow {

    private final String parentQuestionCode;
    private final String childQuestionCode;
    private final Integer displayOrder;
    private final String additionalInfo;

    public ParentQuestionMappingRow(String parentQuestionCode,
                                    String childQuestionCode,
                                    Integer displayOrder,
                                    String additionalInfo) {
        this.parentQuestionCode = parentQuestionCode;
        this.childQuestionCode = childQuestionCode;
        this.displayOrder = displayOrder;
        this.additionalInfo = additionalInfo;
    }

    public String getParentQuestionCode() {
        return parentQuestionCode;
    }

    public String getChildQuestionCode() {
        return childQuestionCode;
    }

    public Integer getDisplayOrder() {
        return displayOrder;
    }

    public String getAdditionalInfo() {
        return additionalInfo;
    }
}
package com.rbs.risk.cradle.climate.migration.domain;

public interface ModelVersionService {

    /**
     * Compute version info for a given modelCode and upgradeType.
     * Implementation will query DB and apply your version rules.
     */
    ModelVersionInfo computeModelVersionInfo(String modelCode, UpgradeType upgradeType);
}
package com.rbs.risk.cradle.climate.migration.domain;

import java.util.List;
import java.util.Objects;

/**
 * Shared domain inputs for all generators.
 * Also provides lazy access to ModelVersionInfo.
 */
public class SqlGenerationContext {

    private final String modelCode;
    private final String modelType;
    private final String jira;
    private final String release;
    private final UpgradeType upgradeType;
    private final String rootOutputFolder;

    private final ModelVersionService modelVersionService;

    private final List<ParentQuestionMappingRow> parentQuestionMappings; // may be null or empty

    // Lazy cache
    private ModelVersionInfo cachedModelVersionInfo;

    public SqlGenerationContext(String modelCode,
                                String modelType,
                                String jira,
                                String release,
                                UpgradeType upgradeType,
                                String rootOutputFolder,
                                ModelVersionService modelVersionService,
                                List<ParentQuestionMappingRow> parentQuestionMappings) {

        this.modelCode = Objects.requireNonNull(modelCode, "modelCode must not be null");
        this.modelType = Objects.requireNonNull(modelType, "modelType must not be null");
        this.jira = Objects.requireNonNull(jira, "jira must not be null");
        this.release = Objects.requireNonNull(release, "release must not be null");
        this.upgradeType = Objects.requireNonNull(upgradeType, "upgradeType must not be null");
        this.rootOutputFolder = Objects.requireNonNull(rootOutputFolder, "rootOutputFolder must not be null");
        this.modelVersionService = Objects.requireNonNull(modelVersionService, "modelVersionService must not be null");
        this.parentQuestionMappings = parentQuestionMappings;
    }

    public String getModelCode() {
        return modelCode;
    }

    public String getModelType() {
        return modelType;
    }

    public String getJira() {
        return jira;
    }

    public String getRelease() {
        return release;
    }

    public UpgradeType getUpgradeType() {
        return upgradeType;
    }

    public String getRootOutputFolder() {
        return rootOutputFolder;
    }

    public List<ParentQuestionMappingRow> getParentQuestionMappings() {
        return parentQuestionMappings;
    }

    public ModelVersionInfo getModelVersionInfo() {
        if (cachedModelVersionInfo == null) {
            cachedModelVersionInfo = modelVersionService.computeModelVersionInfo(modelCode, upgradeType);
        }
        return cachedModelVersionInfo;
    }
}
package com.rbs.risk.cradle.climate.migration.spi;

import com.rbs.risk.cradle.climate.migration.domain.GeneratedSqlFile;
import com.rbs.risk.cradle.climate.migration.domain.SqlGenerationContext;

import java.util.List;

/**
 * Contract for all SQL generators.
 */
public interface SqlGenerator {

    /**
     * Generate one or more SQL files (forward + rollback) for this step.
     */
    List<GeneratedSqlFile> generate(SqlGenerationContext context);
}
package com.rbs.risk.cradle.climate.migration.spi;

import java.util.List;

public class MigrationRecipe {

    private final String name;
    private final List<SqlGenerator> generators;

    public MigrationRecipe(String name, List<SqlGenerator> generators) {
        this.name = name;
        this.generators = generators;
    }

    public String getName() {
        return name;
    }

    public List<SqlGenerator> getGenerators() {
        return generators;
    }
}
package com.rbs.risk.cradle.climate.migration.spi;

import com.rbs.risk.cradle.climate.migration.domain.MigrationScenario;

/**
 * Interface to get a recipe per scenario.
 * Implementation is in the business module.
 */
public interface MigrationRecipeRegistry {

    MigrationRecipe recipeFor(MigrationScenario scenario);
}
package com.rbs.risk.cradle.climate.migration.repository;

import java.util.List;

public interface ModelVersionRepository {

    /**
     * Returns raw model version rows for the given modelCode.
     * Implementation will use Spring JDBC in the business module.
     */
    List<ModelVersionRow> findByModelCode(String modelCode);

    final class ModelVersionRow {
        private final long modelVerId;
        private final String modelVersion;
        private final long expiryEventId;

        public ModelVersionRow(long modelVerId, String modelVersion, long expiryEventId) {
            this.modelVerId = modelVerId;
            this.modelVersion = modelVersion;
            this.expiryEventId = expiryEventId;
        }

        public long getModelVerId() {
            return modelVerId;
        }

        public String getModelVersion() {
            return modelVersion;
        }

        public long getExpiryEventId() {
            return expiryEventId;
        }
    }
}
package com.rbs.risk.cradle.climate.migration.repository;

import com.rbs.risk.cradle.climate.migration.repository.ModelVersionRepository;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class JdbcModelVersionRepository implements ModelVersionRepository {

    private final JdbcTemplate jdbcTemplate;

    public JdbcModelVersionRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public List<ModelVersionRow> findByModelCode(String modelCode) {
        // TODO: refine query as per your real schema/query from screenshot
        String sql = """
            SELECT mv.model_ver_id,
                   mv.model_version,
                   mv.expiry_event_id
            FROM cdf_model_version mv
            JOIN cdf_model m ON mv.model_id = m.model_id
            WHERE m.model_code = ?
            ORDER BY mv.model_ver_id
            """;

        return jdbcTemplate.query(
                sql,
                (rs, rowNum) -> new ModelVersionRow(
                        rs.getLong("model_ver_id"),
                        rs.getString("model_version"),
                        rs.getLong("expiry_event_id")
                ),
                modelCode
        );
    }
}
package com.rbs.risk.cradle.climate.migration.service;

import com.rbs.risk.cradle.climate.migration.domain.ModelVersionInfo;
import com.rbs.risk.cradle.climate.migration.domain.ModelVersionService;
import com.rbs.risk.cradle.climate.migration.domain.UpgradeType;
import com.rbs.risk.cradle.climate.migration.repository.ModelVersionRepository;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class ModelVersionServiceImpl implements ModelVersionService {

    private final ModelVersionRepository modelVersionRepository;

    public ModelVersionServiceImpl(ModelVersionRepository modelVersionRepository) {
        this.modelVersionRepository = modelVersionRepository;
    }

    @Override
    public ModelVersionInfo computeModelVersionInfo(String modelCode, UpgradeType upgradeType) {
        List<ModelVersionRepository.ModelVersionRow> rows =
                modelVersionRepository.findByModelCode(modelCode);

        if (rows.isEmpty()) {
            throw new IllegalStateException("No model versions found for modelCode=" + modelCode);
        }

        ModelVersionRepository.ModelVersionRow activeRow = rows.stream()
                .filter(r -> r.getExpiryEventId() == 0L)
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("No active version for modelCode=" + modelCode));

        long activeId = activeRow.getModelVerId();
        String activeVersion = activeRow.getModelVersion();

        String newVersion = computeNewVersionString(activeVersion, upgradeType);
        long newId = computeNewModelVerId(activeId, upgradeType);

        List<Long> existingIds = rows.stream()
                .map(ModelVersionRepository.ModelVersionRow::getModelVerId)
                .collect(Collectors.toList());

        return new ModelVersionInfo(activeId, activeVersion, newId, newVersion, existingIds);
    }

    private String computeNewVersionString(String current, UpgradeType type) {
        String[] parts = current.split("\\.");
        int major = Integer.parseInt(parts[0]);
        int minor = Integer.parseInt(parts[1]);

        return switch (type) {
            case MINOR -> major + "." + (minor + 1);
            case MAJOR -> (major + 1) + ".0";
        };
    }

    private long computeNewModelVerId(long currentId, UpgradeType type) {
        // TODO: refine to exactly match your 1101 -> 1211 / 2101 logic.
        String s = String.format("%04d", currentId);
        char[] digits = s.toCharArray();

        if (type == UpgradeType.MINOR) {
            digits[1] = (char) (digits[1] + 1);
        } else {
            digits[0] = (char) (digits[0] + 1);
        }

        return Long.parseLong(new String(digits));
    }
}
package com.rbs.risk.cradle.climate.migration.generator;

import com.rbs.risk.cradle.climate.migration.domain.GeneratedSqlFile;
import com.rbs.risk.cradle.climate.migration.domain.SqlGenerationContext;
import com.rbs.risk.cradle.climate.migration.spi.SqlGenerator;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
public class CreateModelValuesArtifactsGenerator implements SqlGenerator {

    @Override
    public List<GeneratedSqlFile> generate(SqlGenerationContext ctx) {
        String baseModelFolder = ctx.getRootOutputFolder() + "/db/Model/CDF";
        String tablesFolder      = baseModelFolder + "/Tables";
        String uniqueKeysFolder  = baseModelFolder + "/UniqueKeys";
        String foreignKeysFolder = baseModelFolder + "/ForeignKeys";
        String rollbackFolder    = baseModelFolder + "/Rollback";

        String scriptsFolder = ctx.getRootOutputFolder() + "/db/Code/CDF/Scripts";

        List<GeneratedSqlFile> files = new ArrayList<>();

        files.add(generateTableSql(ctx, tablesFolder));
        files.add(generateUniqueKeySql(ctx, uniqueKeysFolder));
        files.add(generateForeignKeySql(ctx, foreignKeysFolder));
        files.add(generateTableRollbackSql(ctx, rollbackFolder));
        files.add(generateSynonymSql(ctx, scriptsFolder));
        files.add(generateSynonymRollbackSql(ctx, scriptsFolder));
        files.add(generateGrantsSql(ctx, scriptsFolder));

        return files;
    }

    private GeneratedSqlFile generateTableSql(SqlGenerationContext ctx, String folder) {
        String modelCode = ctx.getModelCode();
        String tableName = modelCode + "_MODEL_VALUES";

        // This is close to what you described: drop if exists, then create.
        String sql = """
            -- Drop and create model values table for %s
            DECLARE
                v_count NUMBER;
            BEGIN
                SELECT COUNT(*)
                  INTO v_count
                  FROM user_tables
                 WHERE table_name = UPPER('%s');

                IF v_count = 1 THEN
                    EXECUTE IMMEDIATE 'DROP TABLE %s CASCADE CONSTRAINTS';
                END IF;
            END;
            /
            
            CREATE TABLE %s (
                SCORE_ID       NUMBER,
                VARIABLE_ID    NUMBER,
                VARIABLE_VALUE VARCHAR2(300 BYTE)
            );
            """.formatted(modelCode, tableName, tableName, tableName);

        String fileName = tableName + ".sql";
        return new GeneratedSqlFile(folder, fileName, sql);
    }

    private GeneratedSqlFile generateUniqueKeySql(SqlGenerationContext ctx, String folder) {
        String modelCode = ctx.getModelCode();
        String tableName = modelCode + "_MODEL_VALUES";
        String constraintName = modelCode + "V_AK1"; // Adjust as per your naming rule

        // TODO: refine SQL to match your real UK script
        String sql = """
            -- TODO: add real UNIQUE KEY DDL for %s
            -- Example:
            -- ALTER TABLE %s ADD CONSTRAINT %s UNIQUE (SCORE_ID, VARIABLE_ID);
            """.formatted(tableName, tableName, constraintName);

        String fileName = tableName + "_" + constraintName + ".sql";
        return new GeneratedSqlFile(folder, fileName, sql);
    }

    private GeneratedSqlFile generateForeignKeySql(SqlGenerationContext ctx, String folder) {
        String modelCode = ctx.getModelCode();
        String modelType = ctx.getModelType();

        String tableName = modelCode + "_MODEL_VALUES";

        // TODO: refine naming and referenced table logic
        String fkName;
        String referencedTable;
        if ("CRS".equalsIgnoreCase(modelType)) {
            fkName = "CRSC_" + modelCode + "V_FK";
            referencedTable = "CRS_SCORE";
        } else if ("CTPA".equalsIgnoreCase(modelType)) {
            fkName = "CTPC_" + modelCode + "V_FK";
            referencedTable = "CTPA_SCORE";
        } else {
            fkName = "FK_" + modelCode + "_MODEL_VALUES";
            referencedTable = "CRS_SCORE";
        }

        // TODO: refine SQL to match your real FK script
        String sql = """
            -- TODO: add real FOREIGN KEY DDL for %s
            -- Example:
            -- ALTER TABLE %s ADD CONSTRAINT %s
            --   FOREIGN KEY (SCORE_ID) REFERENCES %s (SCORE_ID);
            """.formatted(tableName, tableName, fkName, referencedTable);

        String fileName = tableName + "_" + fkName + ".sql";
        return new GeneratedSqlFile(folder, fileName, sql);
    }

    private GeneratedSqlFile generateTableRollbackSql(SqlGenerationContext ctx, String folder) {
        String modelCode = ctx.getModelCode();
        String tableName = modelCode + "_MODEL_VALUES";

        // TODO: refine rollback logic if needed
        String sql = """
            -- TODO: rollback script for dropping %s
            -- Example:
            -- DROP TABLE %s CASCADE CONSTRAINTS;
            """.formatted(tableName, tableName);

        String fileName = ctx.getJira() + "_Rollback.sql";
        return new GeneratedSqlFile(folder, fileName, sql);
    }

    private GeneratedSqlFile generateSynonymSql(SqlGenerationContext ctx, String folder) {
        String modelCode = ctx.getModelCode();
        String tableName = modelCode + "_MODEL_VALUES";
        String jira = ctx.getJira();
        String release = ctx.getRelease();

        // TODO: refine synonym SQL to match your naming and schema
        String sql = """
            -- TODO: create synonym for %s
            -- Example:
            -- CREATE OR REPLACE SYNONYM %s FOR CRADLE_CDF.O_%s;
            """.formatted(tableName, tableName, tableName);

        String fileName = "%s_CDF_%s_CRADLE_CDF_U_SYNONYMS.sql"
                .formatted(jira, release);
        return new GeneratedSqlFile(folder, fileName, sql);
    }

    private GeneratedSqlFile generateSynonymRollbackSql(SqlGenerationContext ctx, String folder) {
        String modelCode = ctx.getModelCode();
        String tableName = modelCode + "_MODEL_VALUES";
        String jira = ctx.getJira();
        String release = ctx.getRelease();

        String sql = """
            -- TODO: synonym rollback for %s
            -- Example:
            -- DROP SYNONYM %s;
            """.formatted(tableName, tableName);

        String fileName = "%s_CDF_%s_CRADLE_CDF_U_SYNONYMS_Rollback.sql"
                .formatted(jira, release);
        return new GeneratedSqlFile(folder, fileName, sql);
    }

    private GeneratedSqlFile generateGrantsSql(SqlGenerationContext ctx, String folder) {
        String modelCode = ctx.getModelCode();
        String tableName = modelCode + "_MODEL_VALUES";
        String jira = ctx.getJira();
        String release = ctx.getRelease();

        String sql = """
            -- TODO: grants for %s
            -- Example:
            -- GRANT SELECT, INSERT, UPDATE, DELETE ON %s TO CRADLE_CDF_U;
            -- GRANT SELECT ON %s TO CRADLE_SUPPORT_ROLE;
            -- GRANT SELECT ON %s TO CRADLE_PROD_RO;
            """.formatted(tableName, tableName, tableName, tableName);

        String fileName = "%s_CDF_%s_GRANTS.sql"
                .formatted(jira, release);
        return new GeneratedSqlFile(folder, fileName, sql);
    }
}
package com.rbs.risk.cradle.climate.migration.generator;

import com.rbs.risk.cradle.climate.migration.domain.GeneratedSqlFile;
import com.rbs.risk.cradle.climate.migration.domain.ModelVersionInfo;
import com.rbs.risk.cradle.climate.migration.domain.SqlGenerationContext;
import com.rbs.risk.cradle.climate.migration.spi.SqlGenerator;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
public class ModelVersionMigrationGenerator implements SqlGenerator {

    @Override
    public List<GeneratedSqlFile> generate(SqlGenerationContext ctx) {
        ModelVersionInfo info = ctx.getModelVersionInfo();
        String baseFolder = ctx.getRootOutputFolder() + "/db/Model/CDF/Data";
        String modelCode = ctx.getModelCode();

        List<GeneratedSqlFile> files = new ArrayList<>();

        // Placeholder forward + rollback for merge
        files.add(new GeneratedSqlFile(
                baseFolder,
                modelCode + "_ModelVersion_Merge.sql",
                """
                -- TODO: MERGE statement to insert new model version
                -- new model_ver_id: %d, new model_version: %s
                """.formatted(info.getNewModelVerId(), info.getNewModelVersion())
        ));

        files.add(new GeneratedSqlFile(
                baseFolder,
                modelCode + "_ModelVersion_Merge_Rollback.sql",
                """
                -- TODO: rollback for MERGE (delete new model version)
                -- model_ver_id: %d
                """.formatted(info.getNewModelVerId())
        ));

        // Placeholder forward + rollback for update
        files.add(new GeneratedSqlFile(
                baseFolder,
                modelCode + "_ModelVersion_Update.sql",
                """
                -- TODO: UPDATE script to expire old active model version
                -- and update model_table for old/new versions.
                -- active model_ver_id: %d, new model_ver_id: %d
                """.formatted(info.getActiveModelVerId(), info.getNewModelVerId())
        ));

        files.add(new GeneratedSqlFile(
                baseFolder,
                modelCode + "_ModelVersion_Update_Rollback.sql",
                """
                -- TODO: rollback for UPDATE
                -- set expiry_event_id back to 0 for active model_ver_id: %d
                -- and reset model_table for active + new.
                """.formatted(info.getActiveModelVerId())
        ));

        return files;
    }
}
package com.rbs.risk.cradle.climate.migration.generator;

import com.rbs.risk.cradle.climate.migration.domain.GeneratedSqlFile;
import com.rbs.risk.cradle.climate.migration.domain.ModelVersionInfo;
import com.rbs.risk.cradle.climate.migration.domain.SqlGenerationContext;
import com.rbs.risk.cradle.climate.migration.spi.SqlGenerator;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class LinkedModelVersionMigrationGenerator implements SqlGenerator {

    @Override
    public List<GeneratedSqlFile> generate(SqlGenerationContext ctx) {
        ModelVersionInfo info = ctx.getModelVersionInfo();
        String baseFolder = ctx.getRootOutputFolder() + "/db/Model/CDF/Data";
        String modelCode = ctx.getModelCode();

        StringBuilder forward = new StringBuilder();
        forward.append("-- TODO: MERGE/INSERT into cdf_linked_model_version_id for model ")
               .append(modelCode).append("\n");
        forward.append("-- new model_ver_id: ").append(info.getNewModelVerId()).append("\n");
        forward.append("-- existing model_ver_ids: ").append(info.getExistingModelVerIds()).append("\n");

        StringBuilder rollback = new StringBuilder();
        rollback.append("-- TODO: rollback for linked model version mapping\n")
                .append("-- delete rows where model_ver_id = ").append(info.getNewModelVerId()).append(";\n");

        GeneratedSqlFile forwardFile = new GeneratedSqlFile(
                baseFolder,
                modelCode + "_LinkedModelVersion_Merge.sql",
                forward.toString()
        );

        GeneratedSqlFile rollbackFile = new GeneratedSqlFile(
                baseFolder,
                modelCode + "_LinkedModelVersion_Merge_Rollback.sql",
                rollback.toString()
        );

        return List.of(forwardFile, rollbackFile);
    }
}
package com.rbs.risk.cradle.climate.migration.recipes;

import com.rbs.risk.cradle.climate.migration.domain.MigrationScenario;
import com.rbs.risk.cradle.climate.migration.generator.CreateModelValuesArtifactsGenerator;
import com.rbs.risk.cradle.climate.migration.generator.LinkedModelVersionMigrationGenerator;
import com.rbs.risk.cradle.climate.migration.generator.ModelVersionMigrationGenerator;
import com.rbs.risk.cradle.climate.migration.spi.MigrationRecipe;
import com.rbs.risk.cradle.climate.migration.spi.MigrationRecipeRegistry;
import com.rbs.risk.cradle.climate.migration.spi.SqlGenerator;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

@Component
public class MigrationRecipeRegistryImpl implements MigrationRecipeRegistry {

    private final Map<MigrationScenario, MigrationRecipe> recipes;

    public MigrationRecipeRegistryImpl(CreateModelValuesArtifactsGenerator createModelValuesArtifactsGenerator,
                                       ModelVersionMigrationGenerator modelVersionMigrationGenerator,
                                       LinkedModelVersionMigrationGenerator linkedModelVersionMigrationGenerator) {

        MigrationRecipe migrateWithIncrement = new MigrationRecipe(
                "Migrate model with version increment",
                List.of(
                        createModelValuesArtifactsGenerator,
                        modelVersionMigrationGenerator,
                        linkedModelVersionMigrationGenerator
                )
        );

        MigrationRecipe createTableOnly = new MigrationRecipe(
                "Create model values table only",
                List.of(createModelValuesArtifactsGenerator)
        );

        this.recipes = Map.of(
                MigrationScenario.MIGRATE_MODEL_WITH_INCREMENT, migrateWithIncrement,
                MigrationScenario.CREATE_TABLE_ONLY, createTableOnly
        );
    }

    @Override
    public MigrationRecipe recipeFor(MigrationScenario scenario) {
        MigrationRecipe recipe = recipes.get(scenario);
        if (recipe == null) {
            throw new IllegalArgumentException("No recipe defined for scenario: " + scenario);
        }
        return recipe;
    }
}
package com.rbs.risk.cradle.climate.migration.service;

import com.rbs.risk.cradle.climate.migration.api.MigrationRequest;
import com.rbs.risk.cradle.climate.migration.domain.GeneratedSqlFile;
import com.rbs.risk.cradle.climate.migration.domain.ModelVersionService;
import com.rbs.risk.cradle.climate.migration.domain.ParentQuestionMappingRow;
import com.rbs.risk.cradle.climate.migration.domain.SqlGenerationContext;
import com.rbs.risk.cradle.climate.migration.recipes.MigrationRecipeRegistryImpl;
import com.rbs.risk.cradle.climate.migration.spi.MigrationRecipe;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;

@Service
public class MigrationEngine {

    private final MigrationRecipeRegistryImpl recipeRegistry;
    private final ModelVersionService modelVersionService;

    public MigrationEngine(MigrationRecipeRegistryImpl recipeRegistry,
                           ModelVersionService modelVersionService) {
        this.recipeRegistry = recipeRegistry;
        this.modelVersionService = modelVersionService;
    }

    public List<GeneratedSqlFile> generateScripts(MigrationRequest request) {
        return generateScriptsWithParentMapping(request, Collections.emptyList());
    }

    public List<GeneratedSqlFile> generateScriptsWithParentMapping(
            MigrationRequest request,
            List<ParentQuestionMappingRow> parentMappings
    ) {
        MigrationRecipe recipe = recipeRegistry.recipeFor(request.getScenario());

        SqlGenerationContext context = new SqlGenerationContext(
                request.getModelCode(),
                request.getModelType(),
                request.getJira(),
                request.getRelease(),
                request.getUpgradeType(),
                request.getRootOutputFolder(),
                modelVersionService,
                parentMappings
        );

        return recipe.getGenerators().stream()
                .flatMap(generator -> generator.generate(context).stream())
                .toList();
    }
}
package com.rbs.risk.cradle.climate.migration.controller;

import com.rbs.risk.cradle.climate.migration.api.MigrationRequest;
import com.rbs.risk.cradle.climate.migration.domain.GeneratedSqlFile;
import com.rbs.risk.cradle.climate.migration.domain.ParentQuestionMappingRow;
import com.rbs.risk.cradle.climate.migration.service.MigrationEngine;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@RestController
@RequestMapping("/api/migration")
public class MigrationController {

    private final MigrationEngine migrationEngine;

    public MigrationController(MigrationEngine migrationEngine) {
        this.migrationEngine = migrationEngine;
    }

    @PostMapping("/generate")
    public ResponseEntity<ByteArrayResource> generate(@RequestBody MigrationRequest request) throws Exception {

        List<GeneratedSqlFile> files = migrationEngine.generateScripts(request);
        byte[] zipBytes = zipFiles(files);

        ByteArrayResource resource = new ByteArrayResource(zipBytes);

        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"migration_scripts.zip\"")
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .contentLength(zipBytes.length)
                .body(resource);
    }

    @PostMapping(path = "/generate-with-parent-mapping", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<ByteArrayResource> generateWithParentMapping(
            @RequestPart("request") MigrationRequest request,
            @RequestPart("parentMappingCsv") MultipartFile csvFile
    ) throws Exception {

        List<ParentQuestionMappingRow> mappings = parseParentMappingCsv(csvFile);

        List<GeneratedSqlFile> files = migrationEngine.generateScriptsWithParentMapping(request, mappings);
        byte[] zipBytes = zipFiles(files);

        ByteArrayResource resource = new ByteArrayResource(zipBytes);

        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"migration_scripts_with_parent_mapping.zip\"")
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .contentLength(zipBytes.length)
                .body(resource);
    }

    private List<ParentQuestionMappingRow> parseParentMappingCsv(MultipartFile file) throws Exception {
        List<ParentQuestionMappingRow> result = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {

            String line = reader.readLine(); // header
            if (line == null) {
                return result;
            }

            while ((line = reader.readLine()) != null) {
                if (line.isBlank()) {
                    continue;
                }
                String[] parts = line.split(",", -1);
                String parentCode = parts[0].trim();
                String childCode = parts[1].trim();
                Integer order = parts[2].isBlank() ? null : Integer.parseInt(parts[2].trim());
                String additional = parts.length > 3 ? parts[3].trim() : null;

                result.add(new ParentQuestionMappingRow(parentCode, childCode, order, additional));
            }
        }
        return result;
    }

    private byte[] zipFiles(List<GeneratedSqlFile> files) throws Exception {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try (ZipOutputStream zos = new ZipOutputStream(baos)) {
            for (GeneratedSqlFile file : files) {
                String entryName = file.getFolderPath() + "/" + file.getFileName();
                zos.putNextEntry(new ZipEntry(entryName));
                zos.write(file.getContent().getBytes(StandardCharsets.UTF_8));
                zos.closeEntry();
            }
        }
        return baos.toByteArray();
    }
}
