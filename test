package com.rbs.risk.cradle.climate.migration.parentquest;

public class ParentQuestCsvRecord {

    private final String modelCode;
    private final long modelVerId;
    private final long questionId;
    private final String questionDescription;
    private final int sectionId;
    private final Long moduleId; // nullable
    private final String hasRemovedInUpperVersions; // "" or "Y"
    private final String isParentQuestion; // "Y" or blank
    private final Integer questionOrder; // nullable

    public ParentQuestCsvRecord(String modelCode,
                                long modelVerId,
                                long questionId,
                                String questionDescription,
                                int sectionId,
                                Long moduleId,
                                String hasRemovedInUpperVersions,
                                String isParentQuestion,
                                Integer questionOrder) {
        this.modelCode = modelCode;
        this.modelVerId = modelVerId;
        this.questionId = questionId;
        this.questionDescription = questionDescription;
        this.sectionId = sectionId;
        this.moduleId = moduleId;
        this.hasRemovedInUpperVersions = hasRemovedInUpperVersions;
        this.isParentQuestion = isParentQuestion;
        this.questionOrder = questionOrder;
    }

    public String getModelCode() {
        return modelCode;
    }

    public long getModelVerId() {
        return modelVerId;
    }

    public long getQuestionId() {
        return questionId;
    }

    public String getQuestionDescription() {
        return questionDescription;
    }

    public int getSectionId() {
        return sectionId;
    }

    public Long getModuleId() {
        return moduleId;
    }

    public String getHasRemovedInUpperVersions() {
        return hasRemovedInUpperVersions;
    }

    public String getIsParentQuestion() {
        return isParentQuestion;
    }

    public Integer getQuestionOrder() {
        return questionOrder;
    }
}
package com.rbs.risk.cradle.climate.migration.parentquest;

import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;

@Component
public class ParentQuestCsvParser {

    public List<ParentQuestCsvRecord> parse(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            return List.of();
        }

        try (var reader = new BufferedReader(
                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {

            String headerLine = reader.readLine();
            if (headerLine == null) {
                return List.of();
            }

            String[] headerTokens = headerLine.split(",", -1);
            List<ParentQuestCsvColumn> columns = resolveColumns(headerTokens);

            List<ParentQuestCsvRecord> result = new ArrayList<>();
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.trim().isEmpty()) {
                    continue;
                }
                String[] tokens = line.split(",", -1); // simple split; assumes no embedded commas

                Map<ParentQuestCsvColumn, String> values = new EnumMap<>(ParentQuestCsvColumn.class);
                for (int i = 0; i < tokens.length && i < columns.size(); i++) {
                    ParentQuestCsvColumn col = columns.get(i);
                    if (col != null) {
                        values.put(col, unquote(tokens[i]));
                    }
                }

                String modelCode = values.getOrDefault(ParentQuestCsvColumn.MODEL_CODE, "");
                long modelVerId = parseLong(values.get(ParentQuestCsvColumn.MODEL_VER_ID));
                long questionId = parseLong(values.get(ParentQuestCsvColumn.QUESTION_ID));
                String questionDescription = values.get(ParentQuestCsvColumn.QUESTION_DESCRIPTION);
                int sectionId = (int) parseLong(values.get(ParentQuestCsvColumn.SECTION_ID));
                Long moduleId = parseLongNullable(values.get(ParentQuestCsvColumn.MODULE_ID));
                String hasRemoved = values.getOrDefault(
                        ParentQuestCsvColumn.HAS_REMOVED_IN_UPPER_VERSIONS, "");
                String isParent = values.getOrDefault(
                        ParentQuestCsvColumn.IS_PARENT_QUESTION, "");
                Integer order = parseIntNullable(values.get(ParentQuestCsvColumn.QUESTION_ORDER));

                result.add(new ParentQuestCsvRecord(
                        modelCode,
                        modelVerId,
                        questionId,
                        questionDescription,
                        sectionId,
                        moduleId,
                        hasRemoved,
                        isParent,
                        order
                ));
            }

            return result;
        } catch (Exception ex) {
            throw new IllegalStateException("Failed to parse Parent Quest CSV", ex);
        }
    }

    private List<ParentQuestCsvColumn> resolveColumns(String[] headerTokens) {
        List<ParentQuestCsvColumn> columns = new ArrayList<>();
        for (String token : headerTokens) {
            String header = unquote(token).trim();
            ParentQuestCsvColumn col = Arrays.stream(ParentQuestCsvColumn.values())
                    .filter(c -> c.getHeaderLabel().equalsIgnoreCase(header))
                    .findFirst()
                    .orElse(null);
            columns.add(col);
        }
        return columns;
    }

    private String unquote(String token) {
        String t = token.trim();
        if (t.startsWith("\"") && t.endsWith("\"") && t.length() >= 2) {
            t = t.substring(1, t.length() - 1).replace("\"\"", "\"");
        }
        return t;
    }

    private long parseLong(String value) {
        if (value == null || value.trim().isEmpty()) {
            return 0L;
        }
        return Long.parseLong(value.trim());
    }

    private Long parseLongNullable(String value) {
        if (value == null || value.trim().isEmpty()) {
            return null;
        }
        return Long.valueOf(value.trim());
    }

    private Integer parseIntNullable(String value) {
        if (value == null || value.trim().isEmpty()) {
            return null;
        }
        return Integer.valueOf(value.trim());
    }
}
package com.rbs.risk.cradle.climate.migration.domain;

import com.rbs.risk.cradle.climate.migration.parentquest.ParentQuestCsvRecord;

import java.util.List;

public class SqlGenerationContext {

    // ... existing fields ...

    private List<ParentQuestCsvRecord> parentQuestCsvRecords;

    // ... existing getters/constructors/builder ...

    public List<ParentQuestCsvRecord> getParentQuestCsvRecords() {
        return parentQuestCsvRecords;
    }

    public void setParentQuestCsvRecords(List<ParentQuestCsvRecord> parentQuestCsvRecords) {
        this.parentQuestCsvRecords = parentQuestCsvRecords;
    }
}
package com.rbs.risk.cradle.climate.migration.service;

import com.rbs.risk.cradle.climate.migration.api.MigrationRequest;
import com.rbs.risk.cradle.climate.migration.domain.GeneratedSqlFile;
import com.rbs.risk.cradle.climate.migration.parentquest.ParentQuestCsvRecord;

import java.util.List;

public interface MigrationEngine {

    List<GeneratedSqlFile> generateScripts(MigrationRequest request,
                                           List<ParentQuestCsvRecord> parentQuestCsvRecords);
}
package com.rbs.risk.cradle.climate.migration.parentquest;

public interface ParentQuestMapRepository {

    /**
     * Returns the current maximum PAR_MAP_ID in CRS/CTP_PARENT_QUEST_MAP.
     */
    long findMaxParMapId(String prefix); // prefix = "CRS" or "CTP"
}
package com.rbs.risk.cradle.climate.migration.parentquest;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class JdbcParentQuestMapRepository implements ParentQuestMapRepository {

    private final JdbcTemplate jdbcTemplate;

    public JdbcParentQuestMapRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public long findMaxParMapId(String prefix) {
        String table = prefix + "_PARENT_QUEST_MAP";
        String sql = "SELECT NVL(MAX(PAR_MAP_ID), 0) FROM " + table;
        Long max = jdbcTemplate.queryForObject(sql, Long.class);
        return max != null ? max : 0L;
    }
}
package com.rbs.risk.cradle.climate.migration.generator;

import com.rbs.risk.cradle.climate.migration.domain.GeneratedSqlFile;
import com.rbs.risk.cradle.climate.migration.domain.SqlGenerationContext;
import com.rbs.risk.cradle.climate.migration.parentquest.ParentQuestCsvRecord;
import com.rbs.risk.cradle.climate.migration.parentquest.ParentQuestMapRepository;
import com.rbs.risk.cradle.climate.migration.spi.SqlGenerator;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;

@Component
public class ParentQuestMapGenerator implements SqlGenerator {

    private final ParentQuestMapRepository repository;

    public ParentQuestMapGenerator(ParentQuestMapRepository repository) {
        this.repository = repository;
    }

    @Override
    public List<GeneratedSqlFile> generate(SqlGenerationContext ctx) {

        List<ParentQuestCsvRecord> records = ctx.getParentQuestCsvRecords();
        if (records == null || records.isEmpty()) {
            return List.of(); // no CSV, nothing to generate
        }

        // Only parent questions with a question order
        List<ParentQuestCsvRecord> parentRows = records.stream()
                .filter(r -> r.getIsParentQuestion() != null
                        && r.getIsParentQuestion().trim().equalsIgnoreCase("Y"))
                .filter(r -> r.getQuestionOrder() != null)
                .collect(Collectors.toList());

        if (parentRows.isEmpty()) {
            return List.of();
        }

        String prefix = "CTP".equalsIgnoreCase(ctx.getModelType()) ? "CTP" : "CRS";
        String tableName = prefix + "_PARENT_QUEST_MAP";

        long startParMapId = repository.findMaxParMapId(prefix) + 1;

        List<GeneratedSqlFile> files = new ArrayList<>();
        files.add(buildMergeFile(ctx, tableName, parentRows, startParMapId));
        files.add(buildRollbackFile(ctx, tableName, parentRows.size(), startParMapId));

        return files;
    }

    private GeneratedSqlFile buildMergeFile(SqlGenerationContext ctx,
                                            String tableName,
                                            List<ParentQuestCsvRecord> parentRows,
                                            long startParMapId) {

        List<String> selects = new ArrayList<>();

        long currentId = startParMapId;
        for (ParentQuestCsvRecord row : parentRows) {

            String hasRemoved = row.getHasRemovedInUpperVersions();
            String hasRemovedSql = (hasRemoved == null || hasRemoved.trim().isEmpty())
                    ? "''"
                    : "'" + hasRemoved.trim().toUpperCase(Locale.ROOT) + "'";

            Long moduleId = row.getModuleId();
            if (moduleId == null) {
                // If BA forgot to fill, we still generate NULL (they should fix CSV)
                // You can throw exception instead if you want to force it.
            }

            Integer order = row.getQuestionOrder();

            // Single-line SELECT with aliases, ready to copy/paste style
            String select = "SELECT " +
                    currentId + " PAR_MAP_ID, " +
                    (moduleId == null ? "NULL" : moduleId) + " MODULE_ID, " +
                    row.getQuestionId() + " PARENT_QUESTION_ID, " +
                    row.getModelVerId() + " MODEL_VERSION_ID, " +
                    row.getSectionId() + " SECTION_ID, " +
                    hasRemovedSql + " HAS_REMOVED_IN_UPPER_VERSIONS, " +
                    order + " QUEST_ORDER, " +
                    "0 EXPIRY_EVENT_ID " +
                    "FROM DUAL";

            selects.add(select);
            currentId++;
        }

        String usingBlock = selects.stream()
                .collect(Collectors.joining("\n    UNION ALL\n    "));

        String sql = """
                SET DEFINE OFF;
                MERGE INTO %s CPM
                USING
                (
                    %s
                ) x
                ON (x.PAR_MAP_ID = CPM.PAR_MAP_ID)
                WHEN NOT MATCHED THEN
                    INSERT (PAR_MAP_ID, MODULE_ID, PARENT_QUESTION_ID, MODEL_VERSION_ID, SECTION_ID, HAS_REMOVED_IN_UPPER_VERSIONS, QUEST_ORDER, EXPIRY_EVENT_ID)
                    VALUES (x.PAR_MAP_ID, x.MODULE_ID, x.PARENT_QUESTION_ID, x.MODEL_VERSION_ID, x.SECTION_ID, x.HAS_REMOVED_IN_UPPER_VERSIONS, x.QUEST_ORDER, x.EXPIRY_EVENT_ID);
                COMMIT;
                """.formatted(tableName, usingBlock);

        String folder = ctx.getRootOutputFolder() + "/db/Model/CDF/Data";
        String fileName = tableName + "_MERGE.sql";
        return new GeneratedSqlFile(folder, fileName, sql);
    }

    private GeneratedSqlFile buildRollbackFile(SqlGenerationContext ctx,
                                               String tableName,
                                               int rowCount,
                                               long startParMapId) {

        String jira = ctx.getJira();
        long endId = startParMapId + rowCount - 1;

        String sql = """
                DELETE FROM %s
                 WHERE PAR_MAP_ID BETWEEN %d AND %d;
                COMMIT;
                """.formatted(tableName, startParMapId, endId);

        String folder = ctx.getRootOutputFolder() + "/db/Model/CDF/Data";
        String fileName = "%s_Rollback_%s.sql".formatted(jira, tableName);
        return new GeneratedSqlFile(folder, fileName, sql);
    }
}
package com.rbs.risk.cradle.climate.migration.controller;

import com.rbs.risk.cradle.climate.migration.api.MigrationRequest;
import com.rbs.risk.cradle.climate.migration.domain.GeneratedSqlFile;
import com.rbs.risk.cradle.climate.migration.parentquest.ParentQuestCsvParser;
import com.rbs.risk.cradle.climate.migration.parentquest.ParentQuestCsvRecord;
import com.rbs.risk.cradle.climate.migration.service.MigrationEngine;
import com.rbs.risk.cradle.climate.migration.service.MigrationResponseFormatter;
import io.swagger.annotations.*;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.nio.charset.StandardCharsets;
import java.util.List;

@RestController
@RequestMapping("/api/v1/migration")
@Api(tags = "Migration", description = "Versioned endpoints for generating migration SQL scripts")
public class MigrationController {

    private final MigrationEngine migrationEngine;
    private final MigrationResponseFormatter responseFormatter;
    private final ParentQuestCsvParser parentQuestCsvParser;

    public MigrationController(MigrationEngine migrationEngine,
                               MigrationResponseFormatter responseFormatter,
                               ParentQuestCsvParser parentQuestCsvParser) {
        this.migrationEngine = migrationEngine;
        this.responseFormatter = responseFormatter;
        this.parentQuestCsvParser = parentQuestCsvParser;
    }

    @PostMapping(
            value = "/run",
            consumes = MediaType.MULTIPART_FORM_DATA_VALUE,
            produces = MediaType.TEXT_PLAIN_VALUE
    )
    @ApiOperation(
            value = "Generate migration SQL scripts (preview as plain text)",
            notes = """
                    Generates all SQL files for the given migration request according to the configured recipe
                    and returns a plain-text preview (each file path followed by its SQL content).

                    You can optionally attach a Parent Quest Map CSV as 'parentQuestCsv' to generate
                    PARENT_QUEST_MAP merge/rollback scripts from that CSV.
                    """
    )
    @ApiResponses({
            @ApiResponse(code = 200, message = "SQL generated successfully"),
            @ApiResponse(code = 400, message = "Invalid request payload"),
            @ApiResponse(code = 500, message = "Error while generating SQL")
    })
    public ResponseEntity<String> runMigration(
            @ApiParam(
                    value = "Migration request payload (JSON part named 'request')",
                    required = true
            )
            @RequestPart("request") MigrationRequest request,

            @ApiParam(
                    value = "Parent Quest CSV file (optional)",
                    required = false
            )
            @RequestPart(name = "parentQuestCsv", required = false) MultipartFile parentQuestCsv
    ) {

        List<ParentQuestCsvRecord> csvRecords =
                parentQuestCsvParser.parse(parentQuestCsv);

        List<GeneratedSqlFile> files =
                migrationEngine.generateScripts(request, csvRecords);

        String body = responseFormatter.formatAsPreviewText(files);

        return ResponseEntity
                .ok()
                .contentType(new MediaType("text", "plain", StandardCharsets.UTF_8))
                .body(body);
    }
}
