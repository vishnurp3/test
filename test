package com.rbs.risk.cradle.climate.migration.domain;

public class RulesQuestQuestionRow {

    private final long questionId;
    private final long modelVerId;
    private final String hasRemovedInUpperVersions; // may be null
    private final String questionKey;

    public RulesQuestQuestionRow(long questionId,
                                 long modelVerId,
                                 String hasRemovedInUpperVersions,
                                 String questionKey) {
        this.questionId = questionId;
        this.modelVerId = modelVerId;
        this.hasRemovedInUpperVersions = hasRemovedInUpperVersions;
        this.questionKey = questionKey;
    }

    public long getQuestionId() {
        return questionId;
    }

    public long getModelVerId() {
        return modelVerId;
    }

    public String getHasRemovedInUpperVersions() {
        return hasRemovedInUpperVersions;
    }

    public String getQuestionKey() {
        return questionKey;
    }
}

package com.rbs.risk.cradle.climate.migration.domain;

import java.util.List;

public interface LinkedModelVersionService {

    /**
     * Returns all linked model version IDs for the given modelVerId
     * from CDF_LINKED_MODEL_VERSION_ID.
     */
    List<Long> findLinkedModelVerIds(long modelVerId);
}
package com.rbs.risk.cradle.climate.migration.domain;

import java.util.List;

public interface RulesQuestQuestionService {

    /**
     * Returns all rows that should be inserted into CRS/CTP_MODEL_RULES_QUEST for
     * the given model, including CRS-only "final" question rows.
     *
     * @param modelType         "CRS" or "CTP"
     * @param modelCode         e.g. "SRI"
     * @param activeModelVerId  current active model version id
     * @param linkedModelVerIds linked version ids for the active version
     */
    List<RulesQuestQuestionRow> resolveRulesQuestRows(String modelType,
                                                      String modelCode,
                                                      long activeModelVerId,
                                                      List<Long> linkedModelVerIds);
}
package com.rbs.risk.cradle.climate.migration.domain;

public interface RuleQuestIdService {

    /**
     * Returns the starting RULE_QUEST_ID to use for newly generated rows.
     * Typically max(RULE_QUEST_ID) + 1 for CRS/CTP_MODEL_RULES_QUEST.
     */
    long getStartingRuleQuestId(String modelType);
}
package com.rbs.risk.cradle.climate.migration.repository;

import java.util.List;

public interface LinkedModelVersionRepository {

    /**
     * Returns all non-null linked_model_ver_id for the given model_ver_id.
     */
    List<Long> findLinkedModelVerIds(long modelVerId);
}
package com.rbs.risk.cradle.climate.migration.repository;

import com.rbs.risk.cradle.climate.migration.domain.RulesQuestQuestionRow;

import java.util.List;

public interface RulesQuestQuestionRepository {

    /**
     * Base rows from CRS/CTP_UI_QUEST_HELPLINK_MAP + CRS/CTP_QUESTIONS
     * for the given version ids.
     */
    List<RulesQuestQuestionRow> findBaseRows(String tablePrefix,
                                             long activeModelVerId,
                                             List<Long> linkedModelVerIds);

    /**
     * Fetch question_id + question_key for the given keys from CRS/CTP_QUESTIONS.
     */
    List<QuestionKeyAndId> findQuestionsByKeys(String tablePrefix,
                                               List<String> questionKeys);

    final class QuestionKeyAndId {
        private final long questionId;
        private final String questionKey;

        public QuestionKeyAndId(long questionId, String questionKey) {
            this.questionId = questionId;
            this.questionKey = questionKey;
        }

        public long getQuestionId() {
            return questionId;
        }

        public String getQuestionKey() {
            return questionKey;
        }
    }
}
package com.rbs.risk.cradle.climate.migration.repository;

public interface RuleQuestIdRepository {

    /**
     * Returns the current maximum RULE_QUEST_ID in CRS/CTP_MODEL_RULES_QUEST.
     */
    long findMaxRuleQuestId(String tablePrefix);
}
package com.rbs.risk.cradle.climate.migration.repository;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class JdbcLinkedModelVersionRepository implements LinkedModelVersionRepository {

    private final JdbcTemplate jdbcTemplate;

    public JdbcLinkedModelVersionRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public List<Long> findLinkedModelVerIds(long modelVerId) {
        String sql = """
                SELECT LINKED_MODEL_VER_ID
                  FROM CDF_LINKED_MODEL_VERSION_ID
                 WHERE MODEL_VER_ID = ?
                   AND LINKED_MODEL_VER_ID IS NOT NULL
                """;

        return jdbcTemplate.query(sql, (rs, rowNum) -> rs.getLong(1), modelVerId);
    }
}
package com.rbs.risk.cradle.climate.migration.repository;

import com.rbs.risk.cradle.climate.migration.domain.RulesQuestQuestionRow;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Collections;
import java.util.List;

@Repository
public class JdbcRulesQuestQuestionRepository implements RulesQuestQuestionRepository {

    private final NamedParameterJdbcTemplate jdbc;

    public JdbcRulesQuestQuestionRepository(NamedParameterJdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }

    @Override
    public List<RulesQuestQuestionRow> findBaseRows(String tablePrefix,
                                                    long activeModelVerId,
                                                    List<Long> linkedModelVerIds) {

        String uiTable = tablePrefix + "_UI_QUEST_HELPLINK_MAP";
        String qTable  = tablePrefix + "_QUESTIONS";

        StringBuilder sql = new StringBuilder("""
                SELECT DISTINCT m.QUESTION_ID,
                                m.MODEL_VERSION_ID,
                                m.HAS_REMOVED_IN_UPPER_VERSIONS,
                                q.QUESTION_KEY
                  FROM %s m
                  JOIN %s q ON m.QUESTION_ID = q.QUESTION_ID
                 WHERE m.EXPIRY_EVENT_ID = 0
                   AND m.REQUIRED_BY_UI = 'Y'
                   AND (
                     m.MODEL_VERSION_ID = :activeId
                """.formatted(uiTable, qTable));

        MapSqlParameterSource params = new MapSqlParameterSource()
                .addValue("activeId", activeModelVerId);

        if (linkedModelVerIds != null && !linkedModelVerIds.isEmpty()) {
            sql.append("""
                     OR (m.HAS_REMOVED_IN_UPPER_VERSIONS IS NULL
                         AND m.MODEL_VERSION_ID IN (:linkedIds))
                """);
            params.addValue("linkedIds", linkedModelVerIds);
        }

        sql.append("""
                   )
                 ORDER BY m.QUESTION_ID
                """);

        return jdbc.query(sql.toString(), params, (rs, rowNum) -> new RulesQuestQuestionRow(
                rs.getLong("QUESTION_ID"),
                rs.getLong("MODEL_VERSION_ID"),
                rs.getString("HAS_REMOVED_IN_UPPER_VERSIONS"),
                rs.getString("QUESTION_KEY")
        ));
    }

    @Override
    public List<QuestionKeyAndId> findQuestionsByKeys(String tablePrefix, List<String> questionKeys) {
        if (questionKeys == null || questionKeys.isEmpty()) {
            return Collections.emptyList();
        }

        String qTable = tablePrefix + "_QUESTIONS";

        String sql = """
                SELECT QUESTION_ID, QUESTION_KEY
                  FROM %s
                 WHERE QUESTION_KEY IN (:keys)
                """.formatted(qTable);

        MapSqlParameterSource params = new MapSqlParameterSource()
                .addValue("keys", questionKeys);

        return jdbc.query(sql, params, (rs, rowNum) ->
                new QuestionKeyAndId(rs.getLong("QUESTION_ID"), rs.getString("QUESTION_KEY")));
    }
}
package com.rbs.risk.cradle.climate.migration.repository;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class JdbcRuleQuestIdRepository implements RuleQuestIdRepository {

    private final JdbcTemplate jdbcTemplate;

    public JdbcRuleQuestIdRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public long findMaxRuleQuestId(String tablePrefix) {
        String table = tablePrefix + "_MODEL_RULES_QUEST";
        String sql = "SELECT NVL(MAX(RULE_QUEST_ID), 0) FROM " + table;
        return jdbcTemplate.queryForObject(sql, Long.class);
    }
}
package com.rbs.risk.cradle.climate.migration.service;

import com.rbs.risk.cradle.climate.migration.domain.LinkedModelVersionService;
import com.rbs.risk.cradle.climate.migration.repository.LinkedModelVersionRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class LinkedModelVersionServiceImpl implements LinkedModelVersionService {

    private final LinkedModelVersionRepository repository;

    public LinkedModelVersionServiceImpl(LinkedModelVersionRepository repository) {
        this.repository = repository;
    }

    @Override
    public List<Long> findLinkedModelVerIds(long modelVerId) {
        return repository.findLinkedModelVerIds(modelVerId);
    }
}
package com.rbs.risk.cradle.climate.migration.service;

import com.rbs.risk.cradle.climate.migration.domain.RuleQuestIdService;
import com.rbs.risk.cradle.climate.migration.repository.RuleQuestIdRepository;
import org.springframework.stereotype.Service;

@Service
public class RuleQuestIdServiceImpl implements RuleQuestIdService {

    private final RuleQuestIdRepository repository;

    public RuleQuestIdServiceImpl(RuleQuestIdRepository repository) {
        this.repository = repository;
    }

    @Override
    public long getStartingRuleQuestId(String modelType) {
        String prefix = "CTP".equalsIgnoreCase(modelType) ? "CTP" : "CRS";
        long max = repository.findMaxRuleQuestId(prefix);
        return max + 1;
    }
}
package com.rbs.risk.cradle.climate.migration.service;

import com.rbs.risk.cradle.climate.migration.domain.RulesQuestQuestionRow;
import com.rbs.risk.cradle.climate.migration.domain.RulesQuestQuestionService;
import com.rbs.risk.cradle.climate.migration.repository.RulesQuestQuestionRepository;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class RulesQuestQuestionServiceImpl implements RulesQuestQuestionService {

    private final RulesQuestQuestionRepository repository;

    // baseKey -> finalKey mapping (CRS-only)
    private static final Map<String, String> CRS_BASE_TO_FINAL_KEYS = Map.of(
            "inherentTransRiskScore", "finalInherentTransRiskScore",
            "inherentPhyRiskScore", "finalInherentPhyRiskScore",
            "phyRiskAdaptationScore", "finalPhyRiskAdaptationScore",
            "transitionRiskAbatementScore", "finalTransitionRiskAbatementScore"
    );

    public RulesQuestQuestionServiceImpl(RulesQuestQuestionRepository repository) {
        this.repository = repository;
    }

    @Override
    public List<RulesQuestQuestionRow> resolveRulesQuestRows(String modelType,
                                                             String modelCode,
                                                             long activeModelVerId,
                                                             List<Long> linkedModelVerIds) {

        String prefix = "CTP".equalsIgnoreCase(modelType) ? "CTP" : "CRS";

        List<RulesQuestQuestionRow> baseRows =
                repository.findBaseRows(prefix, activeModelVerId, linkedModelVerIds);

        if (!"CRS".equalsIgnoreCase(modelType)) {
            // For CTP, there is no "final" question logic
            return baseRows;
        }

        // CRS-only logic: add rows for corresponding "final..." questions
        return addCrsFinalQuestionRows(prefix, baseRows);
    }

    private List<RulesQuestQuestionRow> addCrsFinalQuestionRows(String prefix,
                                                                List<RulesQuestQuestionRow> baseRows) {

        // Which base keys are actually present?
        Set<String> baseKeysPresent = baseRows.stream()
                .map(RulesQuestQuestionRow::getQuestionKey)
                .filter(Objects::nonNull)
                .filter(CRS_BASE_TO_FINAL_KEYS::containsKey)
                .collect(Collectors.toSet());

        if (baseKeysPresent.isEmpty()) {
            return baseRows;
        }

        // Determine final keys to fetch
        List<String> finalKeys = baseKeysPresent.stream()
                .map(CRS_BASE_TO_FINAL_KEYS::get)
                .distinct()
                .toList();

        // Fetch their question IDs from CRS_QUESTIONS
        var keyAndIds = repository.findQuestionsByKeys(prefix, finalKeys);

        Map<String, Long> finalKeyToId = keyAndIds.stream()
                .collect(Collectors.toMap(
                        RulesQuestQuestionRepository.QuestionKeyAndId::getQuestionKey,
                        RulesQuestQuestionRepository.QuestionKeyAndId::getQuestionId
                ));

        List<RulesQuestQuestionRow> extraRows = new ArrayList<>();

        for (RulesQuestQuestionRow base : baseRows) {
            String baseKey = base.getQuestionKey();
            String finalKey = CRS_BASE_TO_FINAL_KEYS.get(baseKey);
            if (finalKey == null) {
                continue;
            }
            Long finalQuestionId = finalKeyToId.get(finalKey);
            if (finalQuestionId == null) {
                continue; // final question not present in DB
            }

            extraRows.add(new RulesQuestQuestionRow(
                    finalQuestionId,
                    base.getModelVerId(),
                    base.getHasRemovedInUpperVersions(),
                    finalKey
            ));
        }

        List<RulesQuestQuestionRow> all = new ArrayList<>(baseRows);
        all.addAll(extraRows);

        // Keep deterministic order (optional, but nice)
        all.sort(Comparator.comparingLong(RulesQuestQuestionRow::getQuestionId));
        return all;
    }
}
package com.rbs.risk.cradle.climate.migration.generator;

import com.rbs.risk.cradle.climate.migration.domain.*;
import com.rbs.risk.cradle.climate.migration.spi.SqlGenerator;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class ModelRulesQuestGenerator implements SqlGenerator {

    private final ModelVersionService modelVersionService;
    private final LinkedModelVersionService linkedModelVersionService;
    private final RulesQuestQuestionService rulesQuestQuestionService;
    private final RuleQuestIdService ruleQuestIdService;

    public ModelRulesQuestGenerator(ModelVersionService modelVersionService,
                                    LinkedModelVersionService linkedModelVersionService,
                                    RulesQuestQuestionService rulesQuestQuestionService,
                                    RuleQuestIdService ruleQuestIdService) {
        this.modelVersionService = modelVersionService;
        this.linkedModelVersionService = linkedModelVersionService;
        this.rulesQuestQuestionService = rulesQuestQuestionService;
        this.ruleQuestIdService = ruleQuestIdService;
    }

    @Override
    public List<GeneratedSqlFile> generate(SqlGenerationContext ctx) {

        // 1. Get active model version info
        ModelVersionInfo info =
                modelVersionService.computeModelVersionInfo(ctx.getModelCode(), ctx.getUpgradeType());

        long activeModelVerId = info.getActiveModelVerId();

        // 2. Get linked ids for active version
        List<Long> linkedIds = linkedModelVersionService.findLinkedModelVerIds(activeModelVerId);

        // 3. Resolve all question rows (base + CRS final questions)
        List<RulesQuestQuestionRow> rows = rulesQuestQuestionService.resolveRulesQuestRows(
                ctx.getModelType(),
                ctx.getModelCode(),
                activeModelVerId,
                linkedIds
        );

        if (rows.isEmpty()) {
            return List.of(); // nothing to generate
        }

        // 4. Determine starting RULE_QUEST_ID
        long startRuleQuestId = ruleQuestIdService.getStartingRuleQuestId(ctx.getModelType());

        String folder = ctx.getRootOutputFolder() + "/db/Model/CDF/Tables";
        String prefix = "CTP".equalsIgnoreCase(ctx.getModelType()) ? "CTP" : "CRS";
        String tableName = prefix + "_MODEL_RULES_QUEST";

        List<GeneratedSqlFile> files = new ArrayList<>();
        files.add(buildMergeFile(ctx, tableName, rows, startRuleQuestId, folder));
        files.add(buildRollbackFile(ctx, tableName, rows.size(), startRuleQuestId, folder));

        return files;
    }

    private GeneratedSqlFile buildMergeFile(SqlGenerationContext ctx,
                                            String tableName,
                                            List<RulesQuestQuestionRow> rows,
                                            long startRuleQuestId,
                                            String folder) {

        String modelCode = ctx.getModelCode();

        List<String> selects = new ArrayList<>();

        long currentId = startRuleQuestId;
        for (RulesQuestQuestionRow row : rows) {
            String hasRemovedExpr = row.getHasRemovedInUpperVersions() == null
                    ? "null"
                    : "'" + row.getHasRemovedInUpperVersions() + "'";

            // SINGLE-LINE SELECT with aliases
            String select = "SELECT " + currentId + " RULE_QUEST_ID, '" + modelCode + "' MODEL_CODE, 1 RULE_ID, "
                    + row.getQuestionId() + " QUESTION_ID, "
                    + row.getModelVerId() + " MODEL_VER_ID, "
                    + hasRemovedExpr + " HAS_REMOVED_IN_UPPER_VERSIONS FROM DUAL";

            selects.add(select);
            currentId++;
        }

        String usingBlock = selects.stream()
                .collect(Collectors.joining("\n    UNION ALL\n    "));

        String sql = """
                SET DEFINE OFF;
                MERGE INTO %s CMRQ
                USING
                (
                    %s
                ) x
                ON (x.RULE_QUEST_ID = CMRQ.RULE_QUEST_ID)
                WHEN NOT MATCHED THEN
                    INSERT (RULE_QUEST_ID, MODEL_CODE, RULE_ID, QUESTION_ID, MODEL_VER_ID, HAS_REMOVED_IN_UPPER_VERSIONS)
                    VALUES (x.RULE_QUEST_ID, x.MODEL_CODE, x.RULE_ID, x.QUESTION_ID, x.MODEL_VER_ID, x.HAS_REMOVED_IN_UPPER_VERSIONS);
                COMMIT;
                """.formatted(tableName, usingBlock);

        String fileName = tableName + "_MERGE.sql";
        return new GeneratedSqlFile(folder, fileName, sql);
    }

    private GeneratedSqlFile buildRollbackFile(SqlGenerationContext ctx,
                                               String tableName,
                                               int rowCount,
                                               long startRuleQuestId,
                                               String folder) {

        String jira = ctx.getJira();
        long endId = startRuleQuestId + rowCount - 1;

        String sql = """
                DELETE FROM %s
                 WHERE RULE_QUEST_ID BETWEEN %d AND %d;
                COMMIT;
                """.formatted(tableName, startRuleQuestId, endId);

        String fileName = "%s_Rollback_%s.sql".formatted(jira, tableName);
        return new GeneratedSqlFile(folder, fileName, sql);
    }
}
