package com.rbs.risk.cradle.climate.migration.crs.service;

import java.io.InputStream;

public interface CrsMigrationService {

    /**
     * Runs the CRS DB migration for a model and persists parent question mappings
     * based on the provided CSV.
     *
     * @param modelCode the CRS model code
     * @param csvInput  CSV input stream (template filled by user)
     * @return number of parent mappings successfully merged
     */
    int migrateAndPersistParentMappings(String modelCode, InputStream csvInput);
}
package com.rbs.risk.cradle.climate.migration.crs.api;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

@ApiModel("CRS Migration Result")
public class CrsMigrationResponse {

    @ApiModelProperty("Model code for which migration was run")
    private String modelCode;

    @ApiModelProperty("Number of parent question mappings inserted")
    private int insertedCount;

    public CrsMigrationResponse() {
    }

    public CrsMigrationResponse(String modelCode, int insertedCount) {
        this.modelCode = modelCode;
        this.insertedCount = insertedCount;
    }

    public String getModelCode() {
        return modelCode;
    }

    public int getInsertedCount() {
        return insertedCount;
    }

    public void setModelCode(String modelCode) {
        this.modelCode = modelCode;
    }

    public void setInsertedCount(int insertedCount) {
        this.insertedCount = insertedCount;
    }
}
package com.rbs.risk.cradle.climate.migration.crs.repository;

public interface CrsMigrationRepository {

    void runMigrationProcedure(String modelCode);

    long getMaxParentQuestionId();

    /**
     * Execute MERGE for a single parent question mapping.
     * Only inserts when not matched (by parent id).
     */
    void mergeParentMapping(long parentId,
                            String modelCode,
                            long questionId,
                            long moduleId,
                            long sectionId,
                            Long questionOrder);
}
package com.rbs.risk.cradle.climate.migration.crs.repository.impl;

import com.rbs.risk.cradle.climate.migration.crs.constants.CrsMigrationConstants;
import com.rbs.risk.cradle.climate.migration.crs.repository.CrsMigrationRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.core.simple.SimpleJdbcCall;
import org.springframework.stereotype.Repository;

import javax.annotation.PostConstruct;
import java.sql.Types;

@Slf4j
@Repository
public class CrsMigrationJdbcRepository implements CrsMigrationRepository {

    private final JdbcTemplate jdbcTemplate;
    private SimpleJdbcCall migrateCall;

    public CrsMigrationJdbcRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    void init() {
        log.info("{}Initializing migration stored procedure call", CrsMigrationConstants.LOG_PREFIX);

        this.migrateCall = new SimpleJdbcCall(jdbcTemplate)
                // Add withSchemaName(...) / withCatalogName(...) here if needed
                .withProcedureName(CrsMigrationConstants.PROC_MIGRATE_MODEL)
                .withoutProcedureColumnMetaDataAccess()
                .declareParameters(
                        new SqlParameter("p_model_code", Types.VARCHAR)
                );
    }

    @Override
    public void runMigrationProcedure(String modelCode) {
        log.info("{}Executing migration procedure {} for model {}",
                CrsMigrationConstants.LOG_PREFIX,
                CrsMigrationConstants.PROC_MIGRATE_MODEL,
                modelCode);

        migrateCall.execute(modelCode);
    }

    @Override
    public long getMaxParentQuestionId() {
        String sql = "SELECT NVL(MAX(" + CrsMigrationConstants.COL_PARENT_ID + "), 0) " +
                     "FROM " + CrsMigrationConstants.PARENT_MAP_TABLE;

        Long max = jdbcTemplate.queryForObject(sql, Long.class);
        long result = max != null ? max : 0L;

        log.info("{}Current max {} in {} is {}",
                CrsMigrationConstants.LOG_PREFIX,
                CrsMigrationConstants.COL_PARENT_ID,
                CrsMigrationConstants.PARENT_MAP_TABLE,
                result);

        return result;
    }

    @Override
    public void mergeParentMapping(long parentId,
                                   String modelCode,
                                   long questionId,
                                   long moduleId,
                                   long sectionId,
                                   Long questionOrder) {

        String sql = ""
                + "MERGE INTO " + CrsMigrationConstants.PARENT_MAP_TABLE + " tgt\n"
                + "USING (SELECT ? AS " + CrsMigrationConstants.COL_PARENT_ID + ", "
                + "              ? AS " + CrsMigrationConstants.COL_MODEL_CODE + ", "
                + "              ? AS " + CrsMigrationConstants.COL_QUESTION_ID + ", "
                + "              ? AS " + CrsMigrationConstants.COL_MODULE_ID + ", "
                + "              ? AS " + CrsMigrationConstants.COL_SECTION_ID + ", "
                + "              ? AS " + CrsMigrationConstants.COL_QUESTION_ORDER
                + "       FROM DUAL) src\n"
                + "ON (tgt." + CrsMigrationConstants.COL_PARENT_ID
                + " = src." + CrsMigrationConstants.COL_PARENT_ID + ")\n"
                + "WHEN NOT MATCHED THEN\n"
                + "  INSERT (" + CrsMigrationConstants.COL_PARENT_ID + ", "
                +              CrsMigrationConstants.COL_MODEL_CODE + ", "
                +              CrsMigrationConstants.COL_QUESTION_ID + ", "
                +              CrsMigrationConstants.COL_MODULE_ID + ", "
                +              CrsMigrationConstants.COL_SECTION_ID + ", "
                +              CrsMigrationConstants.COL_QUESTION_ORDER + ")\n"
                + "  VALUES (src." + CrsMigrationConstants.COL_PARENT_ID + ", "
                +              "src." + CrsMigrationConstants.COL_MODEL_CODE + ", "
                +              "src." + CrsMigrationConstants.COL_QUESTION_ID + ", "
                +              "src." + CrsMigrationConstants.COL_MODULE_ID + ", "
                +              "src." + CrsMigrationConstants.COL_SECTION_ID + ", "
                +              "src." + CrsMigrationConstants.COL_QUESTION_ORDER + ")";

        long orderValue = questionOrder != null ? questionOrder : 0L;

        jdbcTemplate.update(sql,
                parentId,
                modelCode,
                questionId,
                moduleId,
                sectionId,
                orderValue);
    }
}
package com.rbs.risk.cradle.climate.migration.crs.service.impl;

import com.rbs.risk.cradle.climate.migration.crs.api.CrsQuestionTemplateColumns;
import com.rbs.risk.cradle.climate.migration.crs.constants.CrsMigrationConstants;
import com.rbs.risk.cradle.climate.migration.crs.repository.CrsMigrationRepository;
import com.rbs.risk.cradle.climate.migration.crs.service.CrsMigrationService;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.charset.StandardCharsets;

@Slf4j
@Service
public class CrsMigrationServiceImpl implements CrsMigrationService {

    private final CrsMigrationRepository migrationRepository;

    public CrsMigrationServiceImpl(CrsMigrationRepository migrationRepository) {
        this.migrationRepository = migrationRepository;
    }

    @Override
    public int migrateAndPersistParentMappings(String modelCode, InputStream csvInput) {
        // 1) Run migration stored procedure
        migrationRepository.runMigrationProcedure(modelCode);

        // 2) Determine starting parent ID
        long maxId = migrationRepository.getMaxParentQuestionId();
        long nextId = maxId + 1;

        int insertedCount = 0;

        try (Reader reader = new InputStreamReader(csvInput, StandardCharsets.UTF_8)) {

            CSVParser parser = CSVFormat.DEFAULT.builder()
                    .setHeader()
                    .setSkipHeaderRecord(true)
                    .build()
                    .parse(reader);

            for (CSVRecord record : parser) {
                String isParent = valueOrEmpty(record, CrsQuestionTemplateColumns.IS_PARENT);

                if (!"Y".equalsIgnoreCase(isParent)) {
                    // Not a parent, skip
                    continue;
                }

                String csvModelCode  = valueOrEmpty(record, CrsQuestionTemplateColumns.MODEL_CODE);
                String questionIdStr = valueOrEmpty(record, CrsQuestionTemplateColumns.QUESTION_ID);
                String moduleIdStr   = valueOrEmpty(record, CrsQuestionTemplateColumns.MODULE_ID);
                String sectionIdStr  = valueOrEmpty(record, CrsQuestionTemplateColumns.SECTION_ID);
                String orderStr      = valueOrEmpty(record, CrsQuestionTemplateColumns.QUESTION_ORDER);

                Long questionId   = parseLong(questionIdStr);
                Long moduleId     = parseLong(moduleIdStr);
                Long sectionId    = parseLong(sectionIdStr);
                Long questionOrder = parseLong(orderStr);

                if (questionId == null || moduleId == null || sectionId == null) {
                    log.warn("{}Skipping row {}: missing required fields [qId={}, moduleId={}, sectionId={}]",
                            CrsMigrationConstants.LOG_PREFIX,
                            record.getRecordNumber(),
                            questionIdStr, moduleIdStr, sectionIdStr);
                    continue;
                }

                String effectiveModelCode =
                        (csvModelCode != null && !csvModelCode.isBlank())
                                ? csvModelCode
                                : modelCode;

                long parentId = nextId++;

                migrationRepository.mergeParentMapping(
                        parentId,
                        effectiveModelCode,
                        questionId,
                        moduleId,
                        sectionId,
                        questionOrder
                );

                insertedCount++;
            }

        } catch (IOException e) {
            log.error("{}Failed to parse CSV for model {}: {}",
                    CrsMigrationConstants.LOG_PREFIX, modelCode, e.getMessage(), e);
            throw new UncheckedIOException(e);
        }

        log.info("{}Migration completed for model {}. Inserted {} parent mappings.",
                CrsMigrationConstants.LOG_PREFIX, modelCode, insertedCount);

        return insertedCount;
    }

    private String valueOrEmpty(CSVRecord record, String col) {
        String v = record.get(col);
        return v == null ? "" : v.trim();
    }

    private Long parseLong(String s) {
        if (s == null || s.isBlank()) return null;
        try {
            return Long.valueOf(s.trim());
        } catch (NumberFormatException ex) {
            return null;
        }
    }
}
package com.rbs.risk.cradle.climate.migration.crs.web;

import com.rbs.risk.cradle.climate.migration.crs.api.CrsMigrationApiPaths;
import com.rbs.risk.cradle.climate.migration.crs.api.CrsMigrationResponse;
import com.rbs.risk.cradle.climate.migration.crs.constants.CrsMigrationConstants;
import com.rbs.risk.cradle.climate.migration.crs.service.CrsMigrationService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@Slf4j
@RestController
@RequestMapping(CrsMigrationApiPaths.BASE)
@Api(tags = "CRS Migration APIs")
public class CrsMigrationController {

    private final CrsMigrationService migrationService;

    public CrsMigrationController(CrsMigrationService migrationService) {
        this.migrationService = migrationService;
    }

    @ApiOperation("Run CRS migration and persist parent question mappings from CSV")
    @PostMapping(
            value = "/models/{modelCode}/migrate",
            consumes = MediaType.MULTIPART_FORM_DATA_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public ResponseEntity<CrsMigrationResponse> migrate(
            @ApiParam("CRS Model Code")
            @PathVariable String modelCode,
            @ApiParam("Filled question template CSV")
            @RequestPart("file") MultipartFile file) {

        log.info("{}Migration request received for model {} with file {}",
                CrsMigrationConstants.LOG_PREFIX, modelCode, file.getOriginalFilename());

        int inserted = migrationService.migrateAndPersistParentMappings(
                modelCode,
                safeInputStream(file)
        );

        CrsMigrationResponse response = new CrsMigrationResponse(modelCode, inserted);
        return ResponseEntity.ok(response);
    }

    private java.io.InputStream safeInputStream(MultipartFile file) {
        try {
            return file.getInputStream();
        } catch (Exception e) {
            throw new RuntimeException("Unable to read uploaded file", e);
        }
    }
}
@Override
public void mergeParentMapping(long parMapId,
                               String modelCode, // kept if you want to log / validate, not stored in table
                               long questionId,
                               long moduleId,
                               long sectionId,
                               Long questionOrder) {

    long orderValue = (questionOrder != null) ? questionOrder : 0L;

    // Java 17 text block for MERGE SQL
    String sqlTemplate = """
        MERGE INTO %s tgt
        USING (
            SELECT ? AS PAR_MAP_ID,
                   ? AS MODULE_ID,
                   ? AS PARENT_QUESTION_ID,
                   ? AS SECTION_ID,
                   ? AS QUEST_ORDER
            FROM DUAL
        ) src
        ON (tgt.PAR_MAP_ID = src.PAR_MAP_ID)
        WHEN NOT MATCHED THEN
          INSERT (PAR_MAP_ID,
                  MODULE_ID,
                  PARENT_QUESTION_ID,
                  SECTION_ID,
                  QUEST_ORDER,
                  HAS_REMOVED_IN_UPPER_VERSIONS,
                  CREATION_DATE,
                  EXPIRY_EVENT_ID)
          VALUES (src.PAR_MAP_ID,
                  src.MODULE_ID,
                  src.PARENT_QUESTION_ID,
                  src.SECTION_ID,
                  src.QUEST_ORDER,
                  'N',
                  SYSTIMESTAMP,
                  0)
        """;

    String sql = sqlTemplate.formatted(CrsMigrationConstants.PARENT_MAP_TABLE);

    jdbcTemplate.update(sql,
            parMapId,
            moduleId,
            questionId,
            sectionId,
            orderValue);
}
