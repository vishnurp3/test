package com.rbs.risk.cradle.climate.migration.crs.service;

import com.rbs.risk.cradle.climate.migration.crs.api.CrsQuestionTemplateColumns;
import com.rbs.risk.cradle.climate.migration.crs.constants.CrsMigrationConstants;
import com.rbs.risk.cradle.climate.migration.crs.domain.CrsQuestionMetadata;
import com.rbs.risk.cradle.climate.migration.crs.repository.CrsQuestionMetadataRepository;
import com.rbs.risk.cradle.climate.migration.crs.view.CrsQuestionMetadataView;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.UncheckedIOException;
import java.io.Writer;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Stream;

@Slf4j
@Service
public class CrsQuestionTemplateServiceImpl implements CrsQuestionTemplateService {

    private final CrsQuestionMetadataRepository repository;

    public CrsQuestionTemplateServiceImpl(CrsQuestionMetadataRepository repository) {
        this.repository = repository;
    }

    @Override
    public byte[] generateTemplateCsv(String modelCode) {
        log.info("{}Generating CSV template for CRS model {}",
                CrsMigrationConstants.LOG_PREFIX, modelCode);

        // 1) Load from DB (view interface)
        List<CrsQuestionMetadataView> views = repository.findForModelCode(modelCode);

        // 2) Map to domain
        List<CrsQuestionMetadata> questions = mapToDomain(views);

        // 3) Apply business rule: duplicate section 5 into 3 & 4
        List<CrsQuestionMetadata> expanded = expandSpecialSections(questions);

        // 4) Sort into final CSV order
        List<CrsQuestionMetadata> sorted = sortForCsv(expanded);

        // 5) Generate CSV bytes
        return writeCsv(sorted);
    }

    // -----------------------------------------------------------
    // Mapping
    // -----------------------------------------------------------

    private List<CrsQuestionMetadata> mapToDomain(List<CrsQuestionMetadataView> views) {
        return views.stream()
                .map(v -> CrsQuestionMetadata.builder()
                        .modelCode(v.modelCode())
                        .modelVersionId(v.modelVersionId())
                        .questionId(v.questionId())
                        .questionKey(v.questionKey())
                        .questionText(v.questionText())
                        .moduleId(v.moduleId())
                        .sectionId(v.sectionId())
                        .build())
                .toList();
    }

    // -----------------------------------------------------------
    // Business rule: sectionId 5 â†’ two rows with 3 & 4
    // -----------------------------------------------------------

    private List<CrsQuestionMetadata> expandSpecialSections(List<CrsQuestionMetadata> list) {
        return list.stream()
                .flatMap(this::expandSectionIfNeeded)
                .toList();
    }

    private Stream<CrsQuestionMetadata> expandSectionIfNeeded(CrsQuestionMetadata q) {
        Long sectionId = q.sectionId();
        if (sectionId != null
                && sectionId.equals(CrsMigrationConstants.SPECIAL_SECTION_ID_DUPLICATE)) {

            log.debug("{}Duplicating question {} from section {} to {} and {}",
                    CrsMigrationConstants.LOG_PREFIX,
                    q.questionId(),
                    sectionId,
                    CrsMigrationConstants.DUPLICATE_SECTION_ID_FIRST,
                    CrsMigrationConstants.DUPLICATE_SECTION_ID_SECOND);

            return Stream.of(
                    q.withSectionId(CrsMigrationConstants.DUPLICATE_SECTION_ID_FIRST),
                    q.withSectionId(CrsMigrationConstants.DUPLICATE_SECTION_ID_SECOND)
            );
        }
        return Stream.of(q);
    }

    // -----------------------------------------------------------
    // Sorting
    // -----------------------------------------------------------

    private List<CrsQuestionMetadata> sortForCsv(List<CrsQuestionMetadata> list) {

        // 1) Sort by section ID (numeric, null last)
        List<CrsQuestionMetadata> bySection = sortBySection(list);

        // 2) Within each section, sort by module ID
        List<CrsQuestionMetadata> bySectionAndModule = sortByModuleWithinSection(bySection);

        // 3) Within each section/module, sort by version and question
        return sortByVersionAndQuestion(bySectionAndModule);
    }

    /**
     * First key: sectionId ascending, nulls last.
     */
    private List<CrsQuestionMetadata> sortBySection(List<CrsQuestionMetadata> list) {
        return list.stream()
                .sorted(Comparator.comparing(
                        CrsQuestionMetadata::sectionId,
                        Comparator.nullsLast(Comparator.naturalOrder())
                ))
                .toList();
    }

    /**
     * Then within each section, sort by moduleId ascending (nulls last).
     */
    private List<CrsQuestionMetadata> sortByModuleWithinSection(List<CrsQuestionMetadata> list) {
        return list.stream()
                .sorted(Comparator
                        .comparing(CrsQuestionMetadata::sectionId,
                                Comparator.nullsLast(Comparator.naturalOrder()))
                        .thenComparing(CrsQuestionMetadata::moduleId,
                                Comparator.nullsLast(Comparator.naturalOrder())))
                .toList();
    }

    /**
     * Finally, within each section/module, sort by modelVersionId then questionId.
     */
    private List<CrsQuestionMetadata> sortByVersionAndQuestion(List<CrsQuestionMetadata> list) {
        return list.stream()
                .sorted(Comparator
                        .comparing(CrsQuestionMetadata::sectionId,
                                Comparator.nullsLast(Comparator.naturalOrder()))
                        .thenComparing(CrsQuestionMetadata::moduleId,
                                Comparator.nullsLast(Comparator.naturalOrder()))
                        .thenComparing(CrsQuestionMetadata::modelVersionId)
                        .thenComparing(CrsQuestionMetadata::questionId))
                .toList();
    }

    // -----------------------------------------------------------
    // CSV generation
    // -----------------------------------------------------------

    private byte[] writeCsv(List<CrsQuestionMetadata> sorted) {
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try (Writer writer = new OutputStreamWriter(baos, StandardCharsets.UTF_8)) {
                writeHeader(writer);
                for (CrsQuestionMetadata q : sorted) {
                    writeRow(writer, q.toCsvColumns());
                }
            }
            return baos.toByteArray();
        } catch (IOException e) {
            log.error("{}CSV generation failed: {}", CrsMigrationConstants.LOG_PREFIX, e.getMessage());
            throw new UncheckedIOException(e);
        }
    }

    private void writeHeader(Writer w) throws IOException {
        writeRow(w, List.of(
                CrsQuestionTemplateColumns.MODEL_CODE,
                CrsQuestionTemplateColumns.QUESTION_ID,
                CrsQuestionTemplateColumns.QUESTION_KEY,
                CrsQuestionTemplateColumns.QUESTION_TEXT,
                CrsQuestionTemplateColumns.MODULE_ID,
                CrsQuestionTemplateColumns.SECTION_ID,
                CrsQuestionTemplateColumns.IS_PARENT,
                CrsQuestionTemplateColumns.QUESTION_ORDER
        ));
    }

    private void writeRow(Writer w, List<String> cols) throws IOException {
        w.write(String.join(",", cols));
        w.write("\n");
    }
}
