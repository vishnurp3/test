package com.rbs.risk.cradle.climate.migration.calculator.domain;

import lombok.Getter;

import java.util.ArrayList;
import java.util.List;

@Getter
public class Module {

    private final long moduleId;
    private final String moduleKey;
    private final List<Question> questions = new ArrayList<>();

    public Module(long moduleId, String moduleKey) {
        this.moduleId = moduleId;
        this.moduleKey = moduleKey;
    }

    public void addQuestion(Question question) {
        if (!questions.contains(question)) {
            questions.add(question);
        }
    }
}
package com.rbs.risk.cradle.climate.migration.calculator.domain;

import lombok.Getter;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@Getter
public class Question implements Comparable<Question> {

    private final long questionId;
    private final String questionKey;
    private final List<Question> children = new ArrayList<>();
    private final List<Variable> variables = new ArrayList<>();
    private int orderInModule;

    public Question(long questionId, String questionKey) {
        this.questionId = questionId;
        this.questionKey = questionKey;
    }

    public void addChild(Question child) {
        if (!children.contains(child)) {
            children.add(child);
        }
    }

    public void addVariable(Variable variable) {
        variables.add(variable);
    }

    public void setOrderInModule(int orderInModule) {
        this.orderInModule = orderInModule;
    }

    @Override
    public int compareTo(Question other) {
        int cmp = Integer.compare(this.orderInModule, other.orderInModule);
        if (cmp != 0) {
            return cmp;
        }
        return Long.compare(this.questionId, other.questionId);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Question question)) return false;
        return questionId == question.questionId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(questionId);
    }
}
package com.rbs.risk.cradle.climate.migration.calculator.domain;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public class Variable {

    private final String variableName;
    private final String prefix;
}
package com.rbs.risk.cradle.climate.migration.calculator.service;

import com.rbs.risk.cradle.climate.migration.calculator.domain.Module;
import com.rbs.risk.cradle.climate.migration.calculator.domain.Question;
import com.rbs.risk.cradle.climate.migration.calculator.domain.Variable;
import com.rbs.risk.cradle.climate.migration.calculator.dto.ParentQuestMapRow;
import com.rbs.risk.cradle.climate.migration.calculator.dto.QuestionVariableRow;
import com.rbs.risk.cradle.climate.migration.calculator.repository.ModelVersionRepository;
import com.rbs.risk.cradle.climate.migration.calculator.repository.ParentQuestMapRepository;
import com.rbs.risk.cradle.climate.migration.calculator.repository.QuestionVariableRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

@Service
@RequiredArgsConstructor
public class CalculatorModelBuilderService {

    private final ModelVersionRepository modelVersionRepository;
    private final QuestionVariableRepository questionVariableRepository;
    private final ParentQuestMapRepository parentQuestMapRepository;

    public List<Module> buildModulesForModel(String modelCode, String modelVersion, int sectionId) {
        var modelVerIds = resolveModelVersionIds(modelCode, modelVersion);
        var questionRows = questionVariableRepository.findQuestionVariables(modelVerIds);
        var parentRows = parentQuestMapRepository.findParentQuestMap(modelVerIds, sectionId);

        var context = buildModelContext(questionRows);

        wireParentChildRelations(context.questionsById(), context.parentByChildId());
        applyQuestionOrders(context.questionsById(), parentRows);
        pruneChildQuestionsFromModules(context.modulesById(), context.parentByChildId().keySet());
        sortQuestionsAndChildren(context.modulesById().values());

        // Actually return modules sorted by moduleId
        return context.modulesById().values().stream()
                .sorted(Comparator.comparingLong(Module::getModuleId))
                .toList();
    }

    private List<Long> resolveModelVersionIds(String modelCode, String modelVersion) {
        var modelVerId = modelVersionRepository.findModelVersionId(modelCode, modelVersion);
        var linkedModelVerId = modelVersionRepository.findLinkedModelVersionId(modelVerId);

        var modelVerIds = new ArrayList<Long>(2);
        modelVerIds.add(modelVerId);
        if (linkedModelVerId != null) {
            modelVerIds.add(linkedModelVerId);
        }
        return modelVerIds;
    }

    /**
     * Single-pass builder over QuestionVariableRow list.
     */
    private ModelBuildContext buildModelContext(List<QuestionVariableRow> questionRows) {
        Map<Long, Question> questionsById = new LinkedHashMap<>();
        Map<Long, Module> modulesById = new LinkedHashMap<>();
        Map<Long, Long> parentByChildId = new LinkedHashMap<>();

        for (var row : questionRows) {
            // Build / enrich Question
            var question = questionsById.computeIfAbsent(
                    row.questionId(),
                    id -> new Question(id, row.questionKey())
            );
            question.addVariable(new Variable(row.variableName(), row.prefix()));

            // Build / enrich Module
            var module = modulesById.computeIfAbsent(
                    row.moduleId(),
                    id -> new Module(id, row.moduleKey())
            );
            module.addQuestion(question);

            // Capture parent mapping, if any
            var parentId = row.parentQuestionId();
            if (parentId != null) {
                parentByChildId.put(row.questionId(), parentId);
            }
        }

        return new ModelBuildContext(modulesById, questionsById, parentByChildId);
    }

    private void wireParentChildRelations(Map<Long, Question> questionsById,
                                          Map<Long, Long> parentByChildId) {
        for (var entry : parentByChildId.entrySet()) {
            var childId = entry.getKey();
            var parentId = entry.getValue();

            var parent = questionsById.get(parentId);
            var child = questionsById.get(childId);

            if (parent != null && child != null) {
                parent.addChild(child);
            }
        }
    }

    private void applyQuestionOrders(Map<Long, Question> questionsById,
                                     List<ParentQuestMapRow> parentRows) {
        for (var row : parentRows) {
            var question = questionsById.get(row.parentQuestionId());
            if (question != null) {
                question.setOrderInModule(row.questOrder());
            }
        }
    }

    private void pruneChildQuestionsFromModules(Map<Long, Module> modulesById,
                                                Set<Long> childIds) {
        for (var module : modulesById.values()) {
            module.getQuestions().removeIf(q -> childIds.contains(q.getQuestionId()));
        }
    }

    private void sortQuestionsAndChildren(Collection<Module> modules) {
        for (var module : modules) {
            module.getQuestions().sort(Question::compareTo);
            for (var question : module.getQuestions()) {
                question.getChildren().sort(Question::compareTo);
            }
        }
    }

    private record ModelBuildContext(
            Map<Long, Module> modulesById,
            Map<Long, Question> questionsById,
            Map<Long, Long> parentByChildId
    ) {}
}
